---
/**
 * MermaidDiagram - Renders Mermaid diagrams from code blocks
 *
 * Detects ```mermaid code blocks in .content and renders them as SVG.
 * Dynamically imports mermaid so there's zero cost on pages without diagrams.
 * Respects current theme (dark/light) and re-renders on theme change.
 * Includes a "source" toggle to view the raw mermaid definition.
 */
---

<script>
  import { onPageReady } from "../utils/lifecycle";

  const FONT_FAMILY = "'Inter Variable', system-ui, sans-serif";

  function getMermaidConfig() {
    const isDark =
      document.documentElement.getAttribute("data-theme") !== "light";

    // Use mermaid "base" theme with custom themeVariables that map
    // to the site's warm color palette (HSL values from global.css)
    const themeVariables = isDark
      ? {
          fontFamily: FONT_FAMILY,
          fontSize: "14px",
          primaryColor: "hsl(20, 10%, 16%)",
          primaryTextColor: "hsl(35, 12%, 87%)",
          primaryBorderColor: "hsl(20, 10%, 24%)",
          secondaryColor: "hsl(35, 20%, 14%)",
          secondaryTextColor: "hsl(35, 12%, 87%)",
          secondaryBorderColor: "hsl(20, 10%, 22%)",
          tertiaryColor: "hsl(20, 12%, 12%)",
          tertiaryTextColor: "hsl(30, 8%, 68%)",
          tertiaryBorderColor: "hsl(20, 10%, 18%)",
          lineColor: "hsl(30, 8%, 45%)",
          textColor: "hsl(35, 12%, 87%)",
          mainBkg: "hsl(20, 10%, 16%)",
          nodeBorder: "hsl(20, 10%, 24%)",
          clusterBkg: "hsl(20, 12%, 11%)",
          clusterBorder: "hsl(20, 10%, 20%)",
          titleColor: "hsl(42, 52%, 76%)",
          edgeLabelBackground: "hsl(20, 12%, 12%)",
          nodeTextColor: "hsl(35, 12%, 87%)",
          actorTextColor: "hsl(35, 12%, 87%)",
          actorBorder: "hsl(20, 10%, 24%)",
          actorBkg: "hsl(20, 10%, 16%)",
          activationBorderColor: "hsl(42, 35%, 58%)",
          activationBkgColor: "hsl(35, 20%, 14%)",
          signalColor: "hsl(35, 12%, 87%)",
          labelBoxBkgColor: "hsl(20, 10%, 16%)",
          labelBoxBorderColor: "hsl(20, 10%, 24%)",
          labelTextColor: "hsl(35, 12%, 87%)",
          loopTextColor: "hsl(30, 8%, 68%)",
          noteBkgColor: "hsl(35, 20%, 14%)",
          noteBorderColor: "hsl(42, 35%, 58%)",
          noteTextColor: "hsl(35, 12%, 87%)",
        }
      : {
          fontFamily: FONT_FAMILY,
          fontSize: "14px",
          primaryColor: "hsl(45, 30%, 88%)",
          primaryTextColor: "hsl(25, 30%, 18%)",
          primaryBorderColor: "hsl(35, 25%, 75%)",
          secondaryColor: "hsl(45, 45%, 90%)",
          secondaryTextColor: "hsl(25, 30%, 18%)",
          secondaryBorderColor: "hsl(35, 25%, 78%)",
          tertiaryColor: "hsl(45, 30%, 93%)",
          tertiaryTextColor: "hsl(25, 25%, 35%)",
          tertiaryBorderColor: "hsl(35, 25%, 82%)",
          lineColor: "hsl(25, 15%, 55%)",
          textColor: "hsl(25, 30%, 18%)",
          mainBkg: "hsl(45, 30%, 88%)",
          nodeBorder: "hsl(35, 25%, 75%)",
          clusterBkg: "hsl(45, 35%, 94%)",
          clusterBorder: "hsl(35, 25%, 82%)",
          titleColor: "hsl(28, 80%, 38%)",
          edgeLabelBackground: "hsl(45, 30%, 92%)",
          nodeTextColor: "hsl(25, 30%, 18%)",
          actorTextColor: "hsl(25, 30%, 18%)",
          actorBorder: "hsl(35, 25%, 75%)",
          actorBkg: "hsl(45, 30%, 88%)",
          activationBorderColor: "hsl(28, 60%, 48%)",
          activationBkgColor: "hsl(45, 45%, 90%)",
          signalColor: "hsl(25, 30%, 18%)",
          labelBoxBkgColor: "hsl(45, 30%, 88%)",
          labelBoxBorderColor: "hsl(35, 25%, 75%)",
          labelTextColor: "hsl(25, 30%, 18%)",
          loopTextColor: "hsl(25, 25%, 35%)",
          noteBkgColor: "hsl(45, 45%, 90%)",
          noteBorderColor: "hsl(28, 60%, 48%)",
          noteTextColor: "hsl(25, 30%, 18%)",
        };

    return {
      startOnLoad: false,
      theme: "base" as const,
      fontFamily: FONT_FAMILY,
      themeVariables,
    };
  }

  onPageReady(() => {
    const pres = document.querySelectorAll<HTMLPreElement>(
      '.content pre[data-language="mermaid"]',
    );
    if (pres.length === 0) return;

    interface DiagramEntry {
      rendered: HTMLDivElement;
      source: string;
      sourceBlock: HTMLPreElement;
      toggleBtn: HTMLButtonElement;
    }

    const diagrams: DiagramEntry[] = [];

    pres.forEach((pre) => {
      const code = pre.querySelector("code");
      if (!code) return;

      const source = code.textContent ?? "";

      const container = document.createElement("div");
      container.className = "mermaid-container";

      const rendered = document.createElement("div");
      rendered.className = "mermaid mermaid-rendered";
      rendered.textContent = source;

      const sourceBlock = document.createElement("pre");
      sourceBlock.className = "mermaid-source";
      sourceBlock.hidden = true;
      const sourceCode = document.createElement("code");
      sourceCode.textContent = source;
      sourceBlock.appendChild(sourceCode);

      const toolbar = document.createElement("div");
      toolbar.className = "mermaid-toolbar";

      const toggleBtn = document.createElement("button");
      toggleBtn.className = "mermaid-toggle";
      toggleBtn.setAttribute("aria-label", "View diagram source");
      toggleBtn.innerHTML =
        '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">' +
        '<polyline points="16 18 22 12 16 6"></polyline>' +
        '<polyline points="8 6 2 12 8 18"></polyline>' +
        "</svg>" +
        "<span>source</span>";

      toggleBtn.addEventListener("click", () => {
        const showing = !sourceBlock.hidden;
        sourceBlock.hidden = showing;
        rendered.style.display = showing ? "" : "none";
        toggleBtn.classList.toggle("is-active", !showing);
        toggleBtn.setAttribute(
          "aria-label",
          showing ? "View diagram source" : "View rendered diagram",
        );
      });

      toolbar.appendChild(toggleBtn);
      container.appendChild(rendered);
      container.appendChild(sourceBlock);
      container.appendChild(toolbar);

      const target = pre.closest(".code-wrapper") ?? pre;
      target.replaceWith(container);

      diagrams.push({ rendered, source, sourceBlock, toggleBtn });
    });

    if (diagrams.length === 0) return;

    let mermaidModule: typeof import("mermaid")["default"] | null = null;
    let isRendering = false;

    async function renderAll(isThemeSwitch = false): Promise<void> {
      if (isRendering) return;
      isRendering = true;

      try {
        if (!mermaidModule) {
          const mod = await import("mermaid");
          mermaidModule = mod.default;
        }

        mermaidModule.initialize(getMermaidConfig());

        // Render into offscreen temp elements so the visible diagram
        // stays intact until the new SVG is ready
        const offscreen = document.createElement("div");
        offscreen.style.cssText =
          "position:absolute;left:-9999px;top:-9999px;visibility:hidden";
        document.body.appendChild(offscreen);

        const tempNodes: HTMLDivElement[] = [];
        for (const { source } of diagrams) {
          const temp = document.createElement("div");
          temp.className = "mermaid";
          temp.textContent = source;
          offscreen.appendChild(temp);
          tempNodes.push(temp);
        }

        await mermaidModule.run({ nodes: tempNodes });

        // Fade out, swap SVG, fade in
        if (isThemeSwitch) {
          diagrams.forEach((d) => d.rendered.classList.add("is-swapping"));

          // Wait for fade-out transition
          await new Promise((r) => setTimeout(r, 150));
        }

        for (let i = 0; i < diagrams.length; i++) {
          diagrams[i].rendered.innerHTML = tempNodes[i].innerHTML;
        }

        if (isThemeSwitch) {
          // Force reflow before removing class so the browser sees the change
          void diagrams[0]?.rendered.offsetHeight;
          diagrams.forEach((d) => d.rendered.classList.remove("is-swapping"));
        }

        offscreen.remove();
      } finally {
        isRendering = false;
      }
    }

    // Initial render
    renderAll();

    // Re-render on theme change
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (
          mutation.type === "attributes" &&
          mutation.attributeName === "data-theme"
        ) {
          renderAll(true);
          break;
        }
      }
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["data-theme"],
    });
  });
</script>
