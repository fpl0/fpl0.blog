---
/**
 * SearchModal - Full-site fuzzy search with Cmd/Ctrl+K
 * Pre-loads search index at idle time for instant results
 *
 * Architecture:
 * - Uses AbortController for proper event listener cleanup
 * - Singleton pattern prevents duplicate listeners on View Transitions
 * - Debounced search for performance
 */
import "../styles/search-modal.css";
import Link from "./Link.astro";

// Build-time cache buster so browsers fetch fresh search data after each deploy
const searchCacheBuster = Date.now().toString(36);
---

<div class="search-backdrop" id="search-backdrop" data-v={searchCacheBuster}>
  <div class="search-modal" role="dialog" aria-modal="true" aria-label="Search">
    <div class="search-input-wrapper">
      <svg
        class="search-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
      </svg>
      <input
        type="text"
        class="search-input"
        id="search-input"
        placeholder="Search..."
        autocomplete="off"
        spellcheck="false"
        aria-label="Search posts and apps"
      />
      <div class="search-kbd">
        <kbd>esc</kbd>
      </div>
    </div>
    <div
      class="search-results"
      id="search-results"
      role="listbox"
      aria-label="Search results"
      aria-live="polite"
    >
      <div class="search-empty">Type to search...</div>
    </div>
    <div class="search-footer">
      <nav class="search-footer-nav" aria-label="Quick links">
        <Link href="/">home</Link>
        <span class="search-footer-sep">/</span>
        <Link href="/tags/">tags</Link>
      </nav>
      <div class="search-footer-hint">
        <span><kbd>↑</kbd><kbd>↓</kbd> navigate</span>
        <span><kbd>↵</kbd> select</span>
      </div>
    </div>
  </div>
</div>

<script>
  import { navigate } from "astro:transitions/client";
  import { onPageReady } from "../utils/lifecycle";
  import { renderError, renderResults } from "../utils/search-renderer";
  import {
    abortFetch,
    getLatestPosts,
    isIndexLoaded,
    loadSearchIndex,
    searchPosts,
  } from "../utils/search-service";
  import type { SearchItem } from "../utils/search-service";
  import "../utils/search-trigger";

  // Modal state - persists across View Transitions
  let selectedIndex = 0;
  let results: SearchItem[] = [];
  let isInitialized = false;
  let debounceTimer: ReturnType<typeof setTimeout> | null = null;
  let previousActiveElement: Element | null = null;

  const DEBOUNCE_MS = 150;

  function getCacheBuster(): string {
    return document.getElementById("search-backdrop")?.dataset.v ?? "";
  }

  function openSearch(): void {
    const backdrop = document.getElementById("search-backdrop");
    const input = document.getElementById("search-input") as HTMLInputElement | null;

    previousActiveElement = document.activeElement;
    backdrop?.classList.add("is-open");
    document.documentElement.classList.add("is-searching");
    document.body.style.overflow = "hidden";

    // Double rAF ensures the browser has painted visibility:visible before focusing
    requestAnimationFrame(() =>
      requestAnimationFrame(() => {
        input?.focus();
        input?.select();
      }),
    );

    // Show loading state if index not ready
    selectedIndex = 0;
    if (!isIndexLoaded()) {
      renderResults([], selectedIndex, true);
      loadSearchIndex(getCacheBuster(), renderError).then(() => {
        results = getLatestPosts();
        renderResults(results, selectedIndex);
      });
    } else {
      results = getLatestPosts();
      renderResults(results, selectedIndex);
    }
  }

  function closeSearch(): void {
    const backdrop = document.getElementById("search-backdrop");
    const input = document.getElementById("search-input") as HTMLInputElement | null;

    if (debounceTimer) {
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }

    abortFetch();

    backdrop?.classList.remove("is-open");
    document.documentElement.classList.remove("is-searching");
    if (input) input.value = "";
    results = [];
    selectedIndex = 0;
    renderResults([], selectedIndex);
    document.body.style.overflow = "";

    if (previousActiveElement instanceof HTMLElement) {
      previousActiveElement.focus();
    }
    previousActiveElement = null;
  }

  function navigateToSelected(): void {
    const selectedResult = results[selectedIndex];
    if (selectedResult) {
      const url =
        selectedResult.type === "app"
          ? `/apps/${selectedResult.slug}/`
          : `/blog/${selectedResult.slug}/`;
      closeSearch();
      navigate(url);
    }
  }

  function handleKeydown(e: KeyboardEvent): void {
    const backdrop = document.getElementById("search-backdrop");

    // Toggle search with Cmd/Ctrl+K
    if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      backdrop?.classList.contains("is-open") ? closeSearch() : openSearch();
      return;
    }

    // Early return if modal not open
    if (!backdrop?.classList.contains("is-open")) return;

    switch (e.key) {
      case "Escape":
        closeSearch();
        break;
      case "ArrowDown":
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, results.length - 1);
        renderResults(results, selectedIndex);
        break;
      case "ArrowUp":
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, 0);
        renderResults(results, selectedIndex);
        break;
      case "Enter":
        e.preventDefault();
        navigateToSelected();
        break;
      case "Tab": {
        // Focus trap -- keep Tab cycling within the modal
        const modal = backdrop.querySelector(".search-modal");
        if (!modal) break;
        const focusable = modal.querySelectorAll<HTMLElement>(
          'input, button, a[href], [tabindex]:not([tabindex="-1"])',
        );
        if (focusable.length === 0) break;
        const first = focusable[0] as HTMLElement | undefined;
        const last = focusable[focusable.length - 1] as HTMLElement | undefined;
        if (first && last) {
          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault();
            last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault();
            first.focus();
          }
        }
        break;
      }
    }
  }

  // Global keyboard handler - singleton pattern
  if (!isInitialized) {
    isInitialized = true;
    document.addEventListener("keydown", handleKeydown);
  }

  onPageReady((signal) => {
    if (debounceTimer) {
      clearTimeout(debounceTimer);
      debounceTimer = null;
    }
    abortFetch();

    const input = document.getElementById("search-input") as HTMLInputElement | null;
    const resultsContainer = document.getElementById("search-results");
    const backdrop = document.getElementById("search-backdrop");

    // Load search index during browser idle time
    const startLoad = () => loadSearchIndex(getCacheBuster(), renderError);
    if ("requestIdleCallback" in window) {
      requestIdleCallback(() => startLoad());
    } else {
      setTimeout(startLoad, 200);
    }

    backdrop?.addEventListener(
      "click",
      (e) => {
        if (e.target === backdrop) closeSearch();
      },
      { signal },
    );

    input?.addEventListener(
      "input",
      () => {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          selectedIndex = 0;
          results = input.value.trim() ? searchPosts(input.value) : getLatestPosts();
          renderResults(results, selectedIndex);
        }, DEBOUNCE_MS);
      },
      { signal },
    );

    resultsContainer?.addEventListener(
      "click",
      (e) => {
        const result = (e.target as HTMLElement).closest(".search-result");
        if (result) {
          const index = parseInt(result.getAttribute("data-index") ?? "0", 10);
          selectedIndex = index;
          navigateToSelected();
        }
      },
      { signal },
    );

    resultsContainer?.addEventListener(
      "mousemove",
      (e) => {
        const result = (e.target as HTMLElement).closest(".search-result");
        if (result) {
          const index = parseInt(result.getAttribute("data-index") ?? "0", 10);
          if (index !== selectedIndex) {
            selectedIndex = index;
            renderResults(results, selectedIndex);
          }
        }
      },
      { signal },
    );
  });
</script>
