---
/**
 * SearchModal - Full-site fuzzy search with Cmd/Ctrl+K
 * Pre-loads search index at idle time for instant results
 *
 * Architecture:
 * - Uses AbortController for proper event listener cleanup
 * - Singleton pattern prevents duplicate listeners on View Transitions
 * - Debounced search for performance
 */
import "../styles/search-modal.css";
import Link from "./Link.astro";

// Build-time cache buster so browsers fetch fresh search data after each deploy
const searchCacheBuster = Date.now().toString(36);
---

<div class="search-backdrop" id="search-backdrop" data-v={searchCacheBuster}>
  <div class="search-modal" role="dialog" aria-modal="true" aria-label="Search">
    <div class="search-input-wrapper">
      <svg
        class="search-icon"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <circle cx="11" cy="11" r="8"></circle>
        <path d="m21 21-4.35-4.35"></path>
      </svg>
      <input
        type="text"
        class="search-input"
        id="search-input"
        placeholder="Search..."
        autocomplete="off"
        spellcheck="false"
        aria-label="Search posts and apps"
        role="combobox"
        aria-controls="search-results"
        aria-expanded="false"
        aria-activedescendant=""
      />
      <div class="search-kbd">
        <kbd>esc</kbd>
      </div>
    </div>
    <div
      class="search-results"
      id="search-results"
      role="listbox"
      aria-label="Search results"
      aria-live="polite"
    >
      <div class="search-empty">Type to search...</div>
    </div>
    <div class="search-footer">
      <nav class="search-footer-nav" aria-label="Quick links">
        <Link href="/">home</Link>
        <span class="search-footer-sep">/</span>
        <Link href="/tags/">tags</Link>
      </nav>
      <div class="search-footer-hint">
        <span><kbd>↑</kbd><kbd>↓</kbd> navigate</span>
        <span><kbd>↵</kbd> select</span>
      </div>
    </div>
  </div>
</div>

<script>
  import { onPageReady } from "../utils/lifecycle";
  import { SearchController } from "../utils/search-controller";
  import { renderError, renderResults } from "../utils/search-renderer";
  import { loadSearchIndex } from "../utils/search-service";

  let controller: SearchController | null = null;
  let isInitialized = false;

  function getCacheBuster(): string {
    return document.getElementById("search-backdrop")?.dataset.v ?? "";
  }

  // Delegated click handler for search trigger buttons — survives View Transitions
  document.addEventListener("click", (e) => {
    const trigger = (e.target as Element).closest("#site-nav-search, #app-shell-search");
    if (trigger) {
      document.dispatchEvent(
        new KeyboardEvent("keydown", {
          key: "k",
          metaKey: true,
          ctrlKey: true,
          bubbles: true,
        }),
      );
    }
  });

  // Global keyboard handler - singleton pattern
  if (!isInitialized) {
    isInitialized = true;
    document.addEventListener("keydown", (e) => controller?.handleKeydown(e));
  }

  onPageReady((signal) => {
    controller?.cleanup();
    controller = new SearchController(getCacheBuster());

    // Load search index during browser idle time
    const startLoad = () => loadSearchIndex(getCacheBuster(), renderError);
    if ("requestIdleCallback" in window) {
      requestIdleCallback(() => startLoad());
    } else {
      setTimeout(startLoad, 200);
    }

    const backdrop = document.getElementById("search-backdrop");
    const input = document.getElementById("search-input") as HTMLInputElement | null;
    const resultsContainer = document.getElementById("search-results");

    backdrop?.addEventListener(
      "click",
      (e) => {
        if (e.target === backdrop) controller?.close();
      },
      { signal },
    );

    input?.addEventListener(
      "input",
      () => {
        controller?.handleInput(input.value);
      },
      { signal },
    );

    resultsContainer?.addEventListener(
      "click",
      (e) => {
        const result = (e.target as HTMLElement).closest(".search-result");
        if (result && controller) {
          const index = parseInt(result.getAttribute("data-index") ?? "0", 10);
          controller.selectedIndex = index;
          controller.navigateToSelected();
        }
      },
      { signal },
    );

    resultsContainer?.addEventListener(
      "mousemove",
      (e) => {
        const result = (e.target as HTMLElement).closest(".search-result");
        if (result && controller) {
          const index = parseInt(result.getAttribute("data-index") ?? "0", 10);
          if (index !== controller.selectedIndex) {
            controller.selectedIndex = index;
            renderResults(controller.results, controller.selectedIndex);
          }
        }
      },
      { signal },
    );
  });
</script>
